* Automatic package installation
  #+begin_src emacs-lisp
    (require 'package)

    ;; add extra sources to the package archives
    (setq package-archives
          '(("gnu" . "http://elpa.gnu.org/packages/")
            ("melpa" . "https://melpa.org/packages/")
            ("marmalade" . "http://marmalade-repo.org/packages/")))

    (package-initialize)
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package))

    (require 'use-package)
    (setq use-package-always-ensure t)

    ;; assumes that load path is always at default...
    (add-to-list 'load-path "~/.emacs.d/use-package")
    (require 'use-package)
    (setq use-package-always-ensure t)
  #+end_src

* Appearance
  These lines of code disable most of the gui elements used in emacs
  so you can get so much more of that sweet, sweet text on your screen.
  #+begin_src emacs-lisp
  (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (setq inhibit-splash-screen t)
  (setq initial-scratch-message "")
  (setq inhibit-startup-message t)
  #+end_src

** Theme
   The theme that I use, nice for high contrast stuff.
   #+begin_src emacs-lisp
     (use-package grandshell
                  :ensure grandshell-theme
                  :init
                  (load-theme 'grandshell t))

   #+end_src

* Extensions
** Magit
   #+begin_src emacs-lisp
     (use-package magit
       :commands magit-status
       :init
       (setq magit-last-seen-setup-instructions "1.4.0")
       :bind
       ("<f7>" . magit-status))

   #+end_src
** counsel
   #+begin_src emacs-lisp
     (use-package counsel
       :init
       :config
       :bind
       ("M-s" . counsel-git-grep)
       ("C-x f" . counsel-git))

   #+end_src
** ivy
   Replacement for ido/smex etc.
   #+begin_src emacs-lisp
     (use-package flx)
     (use-package ivy
       :init
       (ivy-mode 1)
       (setq ivy-use-virtual-buffers t)
       (setq ivy-height 10)
       (setq ivy-count-format "(%d/%d)")
       (setq ivy-re-builders-alist
             '((t . ivy--regex-fuzzy)))
       (setq ivy-initial-inputs-alist nil)
       :config
       (setq magit-completing-read-function 'ivy-completing-read)
       (global-set-key (kbd "C-x b") 'ivy-switch-buffer)
       (global-set-key (kbd "M-x") 'counsel-M-x)
       :bind
       (:map ivy-minibuffer-map
             ("[tab]" . ivy-alt-done)
             ("<return>" . ivy-alt-done)))

   #+end_src

** company-mode
   auto completion stuff.
   #+begin_src emacs-lisp

     (defun check-expansion ()
       (save-excursion
         (if (looking-at "\\_>") t
           (backward-char 1)
           (if (looking-at "\\.") t
             (backward-char 1)
             (if (looking-at "->") t nil)))))

     ;; try and expand, otherwise return null
     (defun do-yas-expand ()
       (let ((yas/fallback-behavior 'return-nil))
         (yas/expand)))

     (defun tab-indent-or-complete ()
       (interactive)
       (cond
        ((minibufferp)
         (minibuffer-complete))
        (t
         (indent-for-tab-command)
         (if (or (not yas/minor-mode)
                 (null (do-yas-expand)))
             (if (check-expansion)
                 (progn
                   (company-manual-begin)
                   (if (null company-candidates)
                       (progn
                         (company-abort)
                         (indent-for-tab-command)))))))))

     (defun tab-complete-or-next-field ()
       (interactive)
       (if (or (not yas/minor-mode)
               (null (do-yas-expand)))
           (if company-candidates
               (company-complete-selection)
             (if (check-expansion)
                 (progn
                   (company-manual-begin)
                   (if (null company-candidates)
                       (progn
                         (company-abort)
                         (yas-next-field))))
               (yas-next-field)))))

     (defun expand-snippet-or-complete-selection ()
       (interactive)
       (if (or (not yas/minor-mode)
               (null (do-yas-expand))
               (company-abort))
           (company-complete-selection)))

     (defun abort-company-or-yas ()
       (interactive)
       (if (null company-candidates)
           (yas-abort-snippet)
         (company-abort)))

     (use-package company
       :init
       (global-company-mode)
       :config
       (setq company-minimum-prefix-length 1
             company-idle-delay 0)
       :bind
       (:map company-active-map
             ("<tab>" . expand-snippet-or-complete-selection)))


     ;; documentation popup
     (use-package company-quickhelp
       :config
       (company-quickhelp-mode 1)
       :bind
       (:map company-active-map
             ("M-h" . company-quickhelp-manual-begin)))

   #+end_src

** yasnippet
   snippet expansion.
   #+begin_src emacs-lisp
     (use-package yasnippet
       :config
       (yas-global-mode 1)
       (yas-reload-all)
       (setq yas-snippet-dirs (append yas-snippet-dirs
                                      '("~/.emacs.d/snippets" "~/.emacs.d/yasnippets-snippets"))))
   #+end_src

** yankpad
   Extension for snippet expansion
   TODO
   #+begin_src emacs-lisp
     (use-package yankpad
       :ensure t
       :defer 10
       :init
       (setq yankpad-file "~/.emacs.d/yankpad.org"))

   #+end_src

** Visual indentation guides
   #+begin_src emacs-lisp
     (use-package indent-guide
       :config
       (add-hook 'prog-mode-hook 'indent-guide-mode)
       (setq indent-guide-recursive t))
   #+end_src
** Parentheses matching
   #+begin_src emacs-lisp
     (use-package smartparens-config
       :ensure smartparens
       :init
       (smartparens-global-mode)
       :config
       (setq sp-autoescape-string-quote-if-empty t))
       
   #+end_src
** Hungry delete
   Delete all whitespace in the intended direction
   #+begin_src emacs-lisp
     ;; integration with smartparens
     ;; todo: sexp?
     (defun hungry-if-whitespace-backward ()
       (interactive)
       (if (or (string-match-p "[[:blank:]]" (string (preceding-char)))
               (eq (current-column) 0))
           (hungry-delete-backward -1)
         (sp-backward-delete-char)))


     (defun hungry-if-whitespace-forward ()
       (interactive)
       (if (string-match-p "[[:blank:]]" (string (following-char)))
           (hungry-delete-forward -1)
         (sp-delete-char)))

     (defun just-one-space-in-region (beg end)
       "replace all whitespace in the region with single spaces"
       (interactive "r")
       (save-excursion
         (save-restriction
           (narrow-to-region beg end)
           (goto-char (point-min))
           (while (re-search-forward "\\s-+" nil t)
             (replace-match " ")))))

     (defun just-one-space-if-region ()
       (interactive)
       (if (use-region-p)
           (call-interactively 'just-one-space-in-region)
         (call-interactively 'just-one-space)))


     (string-match-p "[[:blank:]]" "   ")

     (use-package hungry-delete
       :init
       (global-hungry-delete-mode)
       :bind
       ("<backspace>" . hungry-if-whitespace-backward)
       ("<deletechar>" . hungry-if-whitespace-forward)
       ("M-SPC" . just-one-space-if-region))


   #+end_src
** Whitespace butler
   Delete whitespace when I save
   #+begin_src emacs-lisp
     (use-package ws-butler
       :defer t
       :init
       (ws-butler-global-mode))
   #+end_src

** Aggressive-indent
   Aggressively indent code and text
   #+begin_src emacs-lisp
     (use-package aggressive-indent
       :init
       (aggressive-indent-global-mode)
       (add-to-list 'aggressive-indent-excluded-modes 'verilog-mode))
   #+end_src

** Swoop
   #+begin_src emacs-lisp
     (use-package swoop
       :bind
       ("C-o" . swoop)
       ("C-M-o" . swoop-multi)
       ("M-o" . swoop-pcre-regexp))
   #+end_src

** Custom
*** Compilation
    #+begin_src emacs-lisp
      (setq compilation-last-buffer nil)
      (defun compile-again (pfx)
        (interactive "p")
        (if (and (eq pfx 1)
                 compilation-last-buffer)
            (progn
              (set-buffer compilation-last-buffer)
              (revert-buffer t t))
          (call-interactively 'compile)))


      ;; some compilation stuff so that it scrolls to the first error when
      ;; it happens
      (setq compilation-scroll-output 'first-error)

      (global-set-key [(f5)] 'compile-again)
      (global-set-key [(f6)] 'next-error)

      ;; require winner mode for the auto closing of the compilation buffer.
      (winner-mode 1)

      (setq compilation-finish-functions 'compile-autoclose)
      ;; Close the compilation window if there was no error at all.
      (defun compile-autoclose (buffer string)
        (cond ((string-match "finished" string)
               (bury-buffer "*compilation*")
               (winner-undo)
               (message "Build successful."))
              (t
               (message "Compilation exited abnormally: %s" string))))
    #+end_src

** flycheck
   #+begin_src emacs-lisp
     (use-package flycheck
       :ensure t
       :init
       (global-flycheck-mode))
   #+end_src

* Mode specific
** c/c++ editing
*** irony
    C/C++ completion using libclang.
#+begin_src emacs-lisp
  (use-package company-irony
    :config
    (eval-after-load 'company
      '(add-to-list 'company-backends 'company-irony)))
#+end_src

** verilog
*** Compiliation
    Follow compilation output
    #+begin_src emacs-lisp
      (add-hook 'verilog-mode-hook (lambda ()
                                     (make-local-variable 'compilation-scroll-output)
                                     (setq compilation-scroll-output t)
                                     ))
    #+end_src
** python
#+begin_src emacs-lisp
  (use-package company-anaconda
    :config
    (eval-after-load 'company
      '(add-to-list 'company-backends 'company-anaconda)))
#+end_src
